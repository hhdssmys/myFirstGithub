#### 参考于
#### [浅谈Java的匿名类](https://www.jianshu.com/p/a59a31eb3a41)
#### [为什么局部内部类和匿名内部类只能访问 final 的局部变量](https://www.runoob.com/w3cnote/inner-lambda-final.html)

1. 内部类中不能定义任何静态的东西，匿名（内部）类也是  
> 内部类只是一种语法糖，其在编译后内部类其实是 static class，再定义静态模块，会造成语法歧义（static{static}）
2. 内部类只能访问 final 的局部变量  
> 内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有没有人再引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。  
> 为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的"copy"  
> 将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？就将局部变量设置为final  
> 总结：拷贝（方法中的局部变量实际上确实会复制为内部类的成员变量使用），互不影响（final）
