#### 转载于[redis 单线程的理解](https://www.cnblogs.com/myseries/p/11733861.html)  
IO阻塞的原理(read操作)：  
1. 等待数据准备，数据在内核空间的准备 ，主要在这里阻塞
2. 将数据从内核空间拷贝到进程用户空间  ，这里就可以同步读取了，虽然不是业务处理逻辑，但是并不是阻塞  
#### 单线程模型
&emsp;&emsp;Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。其中<B>执行命令阶段，由于Redis是单线程来处理命令</B>的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。    
&emsp;&emsp;redis会基于这些建立的连接去探测哪个连接已经接收完了客户端的请求数据（注意：不是探测哪个连接建立好了，而是探测哪个接收完了请求数据SelectKey的就绪集合），而且这里的探测动作就是单线程的开始，一旦探测到则基于接收到的数据开始数据处理阶段，然后返回数据，再继续探测下一个已经接收完请求数据的网络连接。注意，从探测到数据处理再到数据返回，全程单线程。这应该就是所谓的redis单线程。  
#### 为什么说redis能够快速执行: 
>1. 绝大部分请求是纯粹的内存操作（非常快速）  
>2. 采用单线程,避免了不必要的上下文切换和竞争条件  
>3. 非阻塞IO - IO多路复用，Redis采用epoll做为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I/O上浪费过多的时间。  
#### 参考文章
[Linux epoll实现原理详解](https://how2playlife.com/2019/12/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E8%AF%A6%E8%A7%A36%EF%BC%9ALinux%20epoll%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3/)  
[IO模型与Java网络编程模型](https://how2playlife.com/2019/12/13/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8CNIO%E8%AF%A6%E8%A7%A33%EF%BC%9AIO%E6%A8%A1%E5%9E%8B%E4%B8%8EJava%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/)    
