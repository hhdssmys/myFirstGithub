### 参考
### [IO多路复用](https://github.com/lokles/Web-Development-Interview-With-Java/blob/main/Linux%E9%97%AE%E9%A2%98.md)
### [select、poll、epoll之间的区别(搜狗面试)](https://www.cnblogs.com/aspirant/p/9166944.html)

#### 在选择select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点
1. 表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下（遍历就不是无用遍历了），select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调
2. select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善

在Linux系统中，一切都是文件，每一个网络连接（socket）在内核中都是以文件描述符（fd）的形式存放
select实现IO多路复用的实现方式 
```
#select函数实现
使用 fd_set 实现，里面装的是文件描述符，大小限制为 1024bit,64位机应该是2048个fd
select()函数会将 fd_set 数组从用户态一次性的拷入内核态，交由内核处理会大大提升效率
当有数据到达一个描述符时，select函数会返回（在此之前是阻塞的）
然后遍历 fd_set 找到那个有数据到达的文件描述符 O(n)的时间复杂度获取到相关描述符。
缺点：
1、fd_set 不可重用
2、用户态到内核态数据拷贝的开销，每次调用select，都需要把fd集合从用户态拷贝到内核态
3、O(n)时间复杂度的轮询,(每次有数据到来，不能分辨具体是谁，需要每次轮询所有FD找到具体有数据的)
```
poll 实现IO多路复用
```
poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的.
```
epoll实现IO多路复用的实现方式
```
// epoll函数实现
epoll_create() 创建一个白板（是一块用户态和内核态共享的一块内存空间）存放fd_events
epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上。
epoll_wait 当数据ready后，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符 O(1)的时间复杂度获取到相关描述符。
优点：
完全解决了select的所有问题。
1、没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）；
2、效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。
3、内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销
```
epoll支持两种触发模式：
LT:水平触发 当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。   
ET:边缘触发 和 LT 模式不同的是，通知之后进程必须立即处理事件。 下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数， 因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。  
LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无论fd中是否还有数据可读；这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符  
#### 总结
1. select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升
2. select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销
