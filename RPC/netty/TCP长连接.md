### 参考于[徐靖峰：聊聊 TCP 长连接和心跳那些事](https://www.cnkirito.moe/tcp-talk/)
#### 长连接与短连接
#### TCP 本身并没有长短连接的区别 ，长短与否，完全取决于我们怎么用它
>+ 短连接：每次通信时，创建 Socket；一次通信结束，调用 socket.close()。这就是一般意义上的短连接，短连接的好处是管理起来比较简单，存在的连接都是可用的连接，不需要额外的控制手段。
>+ 长连接：每次通信完毕后，不会关闭连接，这样可以做到连接的复用。 长连接的好处是省去了创建连接的耗时。  
  
&emsp;&emsp;短连接和长连接的优势，分别是对方的劣势。想要图简单，不追求高性能，使用短连接合适，这样我们就不需要操心连接状态的管理；想要追求性能，使用长连接，我们就需要担心各种问题：比如<B>端对端连接的维护，连接的保活</B> 。  
+ &emsp;&emsp;稍微说一下 FD 这个参数，他代表了 文件句柄 ，<B>每新增一条连接都会占用新的文件句柄</B>，如果你在使用 TCP 通信的过程中出现了 open too many files 的异常，那就应该检查一下，你是不是创建了太多连接，而没有关闭。细心的读者也会联想到长连接的另一个好处，那就是会占用较少的文件句柄  
#### 长连接的维护
&emsp;&emsp;客户端请求的服务可能分布在多个服务器上(没做同一用户单一负载处理，这种必须是无状态的)，客户端自然需要跟对端创建多条长连接，在 Dubbo 中，客户端和服务端都使用 ip:port 维护了端对端的长连接
#### 连接的保活：保证缓存的 Channel 可用  
KeepAlive 机制是在网络层面保证了连接的可用性 ，但站在应用框架层面我们认为这还不够。主要体现在三个方面：  
+ KeepAlive 的开关是在应用层开启的，但是具体参数（如重试测试，重试间隔时间）的设置却是操作系统级别的，位于操作系统的 /etc/sysctl.conf 配置中，这对于应用来说不够灵活。  
+ KeepAlive 的保活机制只在链路空闲的情况下才会起到作用，假如此时有数据发送，且物理链路已经不通，操作系统这边的链路状态还是 ESTABLISHED，这时会发生什么？自然会走 TCP 重传机制，要知道默认的 TCP 超时重传，指数退避算法也是一个相当长的过程。  
+ KeepAlive 本身是面向网络的，并不面向于应用，当连接不可用，可能是由于应用本身的 GC 频繁，系统 load 高等情况，但网络仍然是通的，此时，应用已经失去了活性，连接应该被认为是不可用的。  
#### 网络层面的 KeepAlive 不足以支撑应用级别的连接可用性，本节就来聊聊应用层的心跳机制是实现连接保活的
应用层心跳的设计细节：  

#### KeepAlive 常见错误
1. ETIMEOUT 超时错误，在发送一个探测保护包经过 (tcp_keepalive_time + tcp_keepalive_intvl * tcp_keepalive_probes) 时间后仍然没有接收到 ACK 确认情况下触发的异常，套接字被关闭
2. EHOSTUNREACH host unreachable(主机不可达) 错误，这个应该是 ICMP 汇报给上层应用的。
3. 链接被重置，终端可能崩溃死机重启之后，接收到来自服务器的报文，然物是人非，前朝往事，只能报以无奈重置宣告之
